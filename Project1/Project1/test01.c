/*
stdio.h
- standard input output의 약자
- 표준 입출력에 관한 함수들을 가지고 있는 파일

#include
-  일종의 명령문으로 포함하라는 의미
*/
#include<stdio.h>
// 현재 작성하는 소스코드에 stdio.h 라는 파일을 포함하라는 의미
#include<stdlib.h>
/*
System 함수
- 컴퓨터의 명령어를 실행하기 위해 사용
- stdlib: standard library의 약자
- system("explorer"); 탐색기 실행
- system("explorer\"http://google.com\""); 인터넷 실행
*/

int main(void) {
	printf("this is line 1...\t");
	printf("this is line 2...\n");
	printf("this is line 3...\'");
	printf("this is line 4...\n");
	printf("this is line 5...\"");
	// printf = print + format (화면 출력 함수)
	// \n(줄바꿈), \t(탭 크기만큼 간격 벌리기), \'(작은 따옴표), \"(큰 따옴표)
	// printf를 사용하기 위해서는 stdio.h파일이 필요

//	system("explorer");
//	system("explorer \"http://google.com\"");
	system("pause");
	// pause: 현재 출력 창의 실행을 잠시 중지시킴
	// dir: 현재 디렉토리의 내용을 출력
	// ipconfig: 현재 시스템의 IP주소를 출력
	// cls: 현재 출력 창의 내용을 모두 지움

	return 0;
}
/*
- main 함수는 C언어 프로그램의 실행이 시작되는 곳
- 모든 C언어 프로그램은 반드시 하나의 메인함수를 가져야 한다
- 중괄호는 main 함수의 영역
- 중괄호 내부의 첫번째 줄에서 마지막 줄까지를 순서대로 한 줄씩 실행

컴파일: ctrl + F7
빌드: ctrl + B
디버깅X 시작: ctrl + F5
*/
/*
* 컴파일이 필요한 이유?
* - C언어는 컴퓨터와 인간이 의사소통을 하기 위한 언어.
* - 하지만 컴퓨터가 이해할 수 있는 의사소통의 방법은 오직 0과 1.
* - 따라서 컴퓨터는 C언어도 그대로 이해하지 못한다
* - 그런데 0과 1의 반복적인 수의 집합으로 명령문을 만들기가 복잡하고,
* - 프로그래밍을 위한 소요 시간이 길며, 업무의 효율성이 나쁘다
* 
* 컴파일?
* - 인간의 언어를 컴퓨터의 언어로 바꾸는 과정
* - 명령문의 집합을 만들 때는 인간이 이해하기 편한 언어로 작성
* - 명령문을 실행할 때는 컴퓨터가 이해하기 쉬운 0과 1의 집합으로 만들어 실행
* 
* High Level Language vs. Low Level Language
* 하이레벨
*	- 인간이 이해하기 쉬운 프로그래밍 언어(자바, 파이썬 등)
* 로우레벨
*	- 컴퓨터가 이해하기 쉬운 프로그래밍 언어(어셈블리)
*	(어셈블리어도 0과 1의 집합은 아니기 때문에 어셈블러로 컴파일 과정이 필요함)
* 
* C언어에서 소스코드가 실행파일이 되는 과정
* 1. test01.c 를
* 2. compile 하게되면 전처리기와 컴파일러를 거쳐
* 3. test01.obj 가 생성되고, 이 파일이
* 4. build 과정을 거쳐서 링커에 의해 라이브러리가 링크되면
* 5. test01.exe 이 만들어짐
* 
* 전처리기: 컴파일을 하기 전에 사전에 처리할 것을 처리하는 과정
*	- 인클루드를 통해 지정된 파일을 가져온다
*	- 문법적 오류가 발생한 경우, 1차적으로 전처리기와 컴파일러에서 오류를 판별하여 컴파일을 중단한다
* 빌드: 오브젝트 파일과 실행파일로 만들기 위해 필요한 각종 라이브러리들을 합치는 작업
* 링크: 오브젝트 파일과 각종 라이브러리들을 연결하는 작업
*/